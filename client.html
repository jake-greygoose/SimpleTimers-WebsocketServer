<!DOCTYPE html>
<html lang="en" data-theme="night">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Timer App Client</title>
  <!-- Load Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Load DaisyUI from CDN -->
  <link href="https://cdn.jsdelivr.net/npm/daisyui@2.51.5/dist/full.css" rel="stylesheet">
  <!-- Load Font Awesome for icons -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css">
  <style>
    /* Custom styles for dark theme selections and disabled buttons */
    .selected-room {
      background-color: #374151 !important; /* Tailwind gray-700 */
      border-left: 4px solid #1e293b !important; /* Tailwind blue-gray-800 */
    }
    .current-room {
      background-color: #1f2937 !important; /* Darker background */
      border-left: 4px solid #3b82f6 !important; /* Blue border */
      position: relative;
    }
    .current-room::after {
      content: "ðŸ‘‰";
      position: absolute;
      right: 8px;
      top: 50%;
      transform: translateY(-50%);
    }
    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }
    /* Fix iOS zoom */
    input[type="text"], input[type="password"], input[type="number"] {
      font-size: 16px !important; /* Prevent iOS zoom on focus */
    }
    /* Mobile overflow fixes */
    @media (max-width: 640px) {
      .mobile-container {
        max-width: 100%;
        padding: 0.5rem;
      }
    }
  </style>
</head>
<body class="bg-gray-900 text-gray-100 p-2 sm:p-4 md:p-8 w-full">
  <div class="max-w-5xl mx-auto">
    <h1 class="text-2xl sm:text-3xl font-bold text-gray-100 mb-4 text-center sm:text-left">Timer App</h1>
    
    <div id="connection-status" class="alert alert-error mb-4 text-center text-sm sm:text-base">
      Disconnected
    </div>
    
    <div class="mb-4">
      <label for="server-url" class="label text-sm sm:text-base">WebSocket Server URL</label>
      <div class="flex flex-wrap gap-2">
        <input type="text" id="server-url" value="wss://simple-timers-wss.onrender.com" placeholder="ws://localhost:8080" class="input input-bordered flex-1 bg-gray-800 border-gray-700 text-gray-100 text-sm sm:text-base mobile-input">
        <div class="flex gap-1">
          <button id="connect-btn" class="btn btn-primary btn-sm sm:btn-md">
            <i class="fas fa-plug sm:mr-1"></i>
            <span class="hidden sm:inline">Connect</span>
          </button>
          <button id="disconnect-btn" class="btn btn-primary btn-sm sm:btn-md" disabled>
            <i class="fas fa-power-off sm:mr-1"></i>
            <span class="hidden sm:inline">Disconnect</span>
          </button>
        </div>
      </div>
    </div>
    
    <!-- Responsive container: stacks on mobile, side-by-side on md+ -->
    <div class="flex flex-col md:flex-row gap-4">
      <!-- Left Panel: Rooms -->
      <div class="flex-1 card bg-gray-800 shadow p-3 sm:p-6 w-full">
        <h2 class="card-title text-lg sm:text-xl mb-2 sm:mb-4">Rooms</h2>
        
        <div class="collapse collapse-arrow mb-4">
          <input type="checkbox" class="peer"> 
          <div class="collapse-title bg-gray-700 rounded-t-lg text-base sm:text-lg font-semibold">
            Create Room
          </div>
          <div class="collapse-content bg-gray-700 rounded-b-lg pt-2"> 
            <div id="create-room-form" class="p-2">
              <div class="mb-2 sm:mb-4">
                <label for="room-name" class="label text-sm sm:text-base p-1">Room Name</label>
                <input type="text" id="room-name" placeholder="My Room" class="input input-bordered w-full bg-gray-600 border-gray-600 text-gray-100 h-8 sm:h-10 text-sm sm:text-base">
              </div>
              <div class="mb-2 sm:mb-4">
                <label for="room-password" class="label text-sm sm:text-base p-1">Password (optional)</label>
                <input type="password" id="room-password" placeholder="Leave empty for no password" class="input input-bordered w-full bg-gray-600 border-gray-600 text-gray-100 h-8 sm:h-10 text-sm sm:text-base mobile-input">
              </div>
              <div class="form-control mb-2 sm:mb-4">
                <label class="cursor-pointer label justify-start gap-2">
                  <input type="checkbox" id="room-public" class="checkbox checkbox-sm sm:checkbox-md" checked>
                  <span class="label-text text-sm sm:text-base">Public Room</span> 
                </label>
              </div>
              <button id="create-room-btn" class="btn btn-primary btn-sm sm:btn-md w-full" disabled>Create Room</button>
            </div>
          </div>
        </div>
        
        <div class="flex justify-between items-center mb-3">
          <h3 class="text-base sm:text-lg font-semibold">Available Rooms</h3>
          <button id="join-private-btn" class="btn btn-primary btn-sm sm:btn-md">
            <i class="fas fa-lock sm:mr-1"></i>
            <span class="hidden sm:inline">Join Private Room</span>
          </button>
        </div>
        
        <div class="mb-3" id="in-room-actions">
          <button id="leave-room-btn" class="btn btn-outline btn-error btn-sm sm:btn-md w-full" disabled>
            <i class="fas fa-sign-out-alt sm:mr-1"></i>
            <span class="inline">Leave Current Room</span>
          </button>
        </div>
        
        <div id="room-list" class="max-h-48 sm:max-h-72 overflow-y-auto rounded-lg mb-4">
          <div class="p-2 bg-gray-700 rounded text-sm sm:text-base">Loading rooms...</div>
        </div>
        
        <!-- Modal for joining private rooms -->
        <div id="join-private-modal" class="modal">
          <div class="modal-box bg-gray-800">
            <h3 class="font-bold text-lg mb-4">Join Private Room</h3>
            <div id="join-room-form">
              <div class="tabs tabs-boxed mb-4">
                <a class="tab tab-active" id="invite-tab">Via Invite</a>
                <a class="tab" id="password-tab">Via Password</a>
              </div>
              
              <div id="invite-panel">
                <div class="mb-4">
                  <label for="join-invite-token" class="label text-sm sm:text-base p-1">Invite Token</label>
                  <input type="text" id="join-invite-token" placeholder="Enter invite token" class="input input-bordered w-full bg-gray-600 border-gray-600 text-gray-100 h-8 sm:h-10 text-sm sm:text-base">
                </div>
              </div>
              
              <div id="password-panel" class="hidden">
                <div class="mb-4">
                  <label for="join-room-id" class="label text-sm sm:text-base p-1">Room ID</label>
                  <input type="text" id="join-room-id" placeholder="Enter room ID" class="input input-bordered w-full bg-gray-600 border-gray-600 text-gray-100 h-8 sm:h-10 text-sm sm:text-base">
                </div>
                <div class="mb-4">
                  <label for="join-room-password" class="label text-sm sm:text-base p-1">Password</label>
                  <input type="password" id="join-room-password" placeholder="Enter room password" class="input input-bordered w-full bg-gray-600 border-gray-600 text-gray-100 h-8 sm:h-10 text-sm sm:text-base">
                </div>
              </div>
              
              <div class="modal-action">
                <button id="join-private-room-btn" class="btn btn-primary">Join Room</button>
                <button id="cancel-join-btn" class="btn">Cancel</button>
              </div>
            </div>
          </div>
          <div class="modal-backdrop" id="modal-backdrop"></div>
        </div>
      </div>
      
      <!-- Right Panel: Timers -->
      <div class="flex-1 card bg-gray-800 shadow p-3 sm:p-6 w-full">
        <div id="current-room-info" class="mb-3 sm:mb-6">
          <h2 class="text-lg sm:text-xl font-semibold mb-2">
            <i class="fas fa-home sm:mr-1"></i> Current Room: <span id="current-room-name" class="font-normal">None</span>
          </h2>
          <div id="room-details" class="bg-gray-700 p-2 sm:p-4 rounded text-sm sm:text-base hidden">
            <div class="mb-1"><strong>Room ID:</strong> <span id="current-room-id" class="break-all"></span></div>
            <div><strong>Invite Token:</strong> <span id="current-room-token" class="break-all"></span></div>
          </div>
        </div>
        
        <div class="collapse collapse-arrow mb-4">
          <input type="checkbox" class="peer"> 
          <div class="collapse-title bg-gray-700 rounded-t-lg text-base sm:text-lg font-semibold">
            Create Timer
          </div>
          <div class="collapse-content bg-gray-700 rounded-b-lg pt-2">
            <div id="create-timer-form" class="p-2">
              <div class="mb-2 sm:mb-4">
                <label for="timer-name" class="label text-sm sm:text-base p-1">Timer Name</label>
                <input type="text" id="timer-name" placeholder="My Timer" class="input input-bordered w-full bg-gray-600 border-gray-600 text-gray-100 h-8 sm:h-10 text-sm sm:text-base mobile-input">
              </div>
              <div class="mb-2 sm:mb-4">
                <label for="timer-duration" class="label text-sm sm:text-base p-1">Duration (seconds)</label>
                <input type="number" id="timer-duration" value="60" min="1" class="input input-bordered w-full bg-gray-600 border-gray-600 text-gray-100 h-8 sm:h-10 text-sm sm:text-base mobile-input">
              </div>
              <button id="create-timer-btn" class="btn btn-primary btn-sm sm:btn-md w-full" disabled>
                <i class="fas fa-plus-circle sm:mr-1"></i>
                <span class="inline sm:inline">Create Timer</span>
              </button>
            </div>
          </div>
        </div>
        
        <h3 class="text-base sm:text-lg font-semibold mb-2">Active Timers</h3>
        <div id="timer-list" class="max-h-48 sm:max-h-72 overflow-y-auto rounded-lg">
          <div class="p-2 bg-gray-700 rounded text-sm sm:text-base">Join a room to see timers</div>
        </div>
      </div>
    </div>
    
    <div class="collapse collapse-arrow mt-4">
      <input type="checkbox" class="peer"> 
      <div class="collapse-title bg-gray-800 rounded-t-lg text-base sm:text-lg font-semibold">
        Connection Log
      </div>
      <div class="collapse-content bg-gray-800 rounded-b-lg pt-2">
        <div id="log-container" class="bg-gray-700 border border-gray-700 rounded p-2 sm:p-4 max-h-32 sm:max-h-40 overflow-y-auto">
          <div class="font-mono text-xs sm:text-sm">Waiting for connection...</div>
        </div>
      </div>
    </div>
  </div>
  
  <script>
    document.addEventListener('DOMContentLoaded', function() {
      console.log('DOM fully loaded - starting application');
      initializeApp();
    });
    
    function initializeApp() {
      // Global variables
      let ws = null;
      let selectedRoomId = null;
      let currentRoomId = null;
      let availableRooms = [];
      let roomTimers = [];
      let timerIntervals = {};
      
      // DOM elements
      const connectBtn = document.getElementById('connect-btn');
      const disconnectBtn = document.getElementById('disconnect-btn');
      const serverUrlInput = document.getElementById('server-url');
      const connectionStatus = document.getElementById('connection-status');
      const logContainer = document.getElementById('log-container');
      
      const roomNameInput = document.getElementById('room-name');
      const roomPasswordInput = document.getElementById('room-password');
      const roomPublicCheckbox = document.getElementById('room-public');
      const createRoomBtn = document.getElementById('create-room-btn');
      
      const joinPrivateBtn = document.getElementById('join-private-btn');
      const joinPrivateModal = document.getElementById('join-private-modal');
      const joinRoomIdInput = document.getElementById('join-room-id');
      const joinRoomPasswordInput = document.getElementById('join-room-password');
      const joinInviteTokenInput = document.getElementById('join-invite-token');
      const joinPrivateRoomBtn = document.getElementById('join-private-room-btn');
      const cancelJoinBtn = document.getElementById('cancel-join-btn');
      const modalBackdrop = document.getElementById('modal-backdrop');
      const inviteTab = document.getElementById('invite-tab');
      const passwordTab = document.getElementById('password-tab');
      const invitePanel = document.getElementById('invite-panel');
      const passwordPanel = document.getElementById('password-panel');
      const leaveRoomBtn = document.getElementById('leave-room-btn');
      
      const roomList = document.getElementById('room-list');
      const currentRoomName = document.getElementById('current-room-name');
      const currentRoomIdElement = document.getElementById('current-room-id');
      const currentRoomToken = document.getElementById('current-room-token');
      const roomDetails = document.getElementById('room-details');
      
      const timerNameInput = document.getElementById('timer-name');
      const timerDurationInput = document.getElementById('timer-duration');
      const createTimerBtn = document.getElementById('create-timer-btn');
      
      const timerList = document.getElementById('timer-list');
      
      // Helper functions
      function logMessage(message, data = null) {
        const now = new Date().toLocaleTimeString();
        const logEntry = document.createElement('div');
        logEntry.className = 'font-mono text-xs sm:text-sm';
        logEntry.textContent = data ? `[${now}] ${message}: ${JSON.stringify(data, null, 2)}` : `[${now}] ${message}`;
        logContainer.appendChild(logEntry);
        logContainer.scrollTop = logContainer.scrollHeight;
      }
      
      function updateConnectionStatus(status) {
        connectionStatus.textContent = status;
        if (status.toLowerCase() === 'connected') {
          connectionStatus.className = 'alert alert-success mb-4 text-center text-sm sm:text-base';
        } else if (status.toLowerCase() === 'connecting') {
          connectionStatus.className = 'alert alert-warning mb-4 text-center text-sm sm:text-base';
        } else {
          connectionStatus.className = 'alert alert-error mb-4 text-center text-sm sm:text-base';
        }
      }
      
      function formatTime(seconds) {
        const minutes = Math.floor(seconds / 60);
        const remainingSeconds = seconds % 60;
        return `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
      }
      
      function getStatusBadge(status) {
        switch(status) {
          case 'created': return '<span class="badge badge-xs sm:badge-sm badge-info">Created</span>';
          case 'ready': return '<span class="badge badge-xs sm:badge-sm badge-info">Ready</span>';
          case 'running': return '<span class="badge badge-xs sm:badge-sm badge-success">Running</span>';
          case 'paused': return '<span class="badge badge-xs sm:badge-sm badge-warning">Paused</span>';
          case 'completed': return '<span class="badge badge-xs sm:badge-sm badge-error">Completed</span>';
          default: return `<span class="badge badge-xs sm:badge-sm">${status}</span>`;
        }
      }
      
      function displayRooms(rooms) {
        roomList.innerHTML = '';
        if (!rooms || rooms.length === 0) {
          const emptyItem = document.createElement('div');
          emptyItem.className = 'p-2 bg-gray-700 rounded text-sm sm:text-base';
          emptyItem.textContent = 'No rooms available';
          roomList.appendChild(emptyItem);
          return;
        }
        
        // Sort rooms: current room first, then public rooms, then private rooms
        const sortedRooms = [...rooms].sort((a, b) => {
          // Current room comes first
          if (a.id === currentRoomId) return -1;
          if (b.id === currentRoomId) return 1;
          
          const aIsPublic = a.is_public === 1 || a.is_public === true;
          const bIsPublic = b.is_public === 1 || b.is_public === true;
          
          // Then public rooms
          if (aIsPublic && !bIsPublic) return -1;
          if (!aIsPublic && bIsPublic) return 1;
          
          // Otherwise sort by name
          return (a.name || '').localeCompare(b.name || '');
        });
        
        sortedRooms.forEach(room => {
          const roomItem = document.createElement('div');
          roomItem.className = 'bg-gray-700 rounded mb-2 text-sm sm:text-base';
          if (room.id === currentRoomId) {
            roomItem.classList.add('current-room');
          }
          roomItem.setAttribute('data-room-id', room.id);
          
          // Container for room info
          const roomContent = document.createElement('div');
          roomContent.className = 'p-2 flex flex-col';
          
          // Flex container for room header
          const roomHeader = document.createElement('div');
          roomHeader.className = 'flex justify-between items-center';
          
          // Room name with icon 
          const isPublic = room.is_public === 1 || room.is_public === true;
          const clientCount = room.client_count || 0;
          const roomNameEl = document.createElement('div');
          roomNameEl.className = 'font-semibold flex items-center gap-1';
          roomNameEl.innerHTML = `${isPublic ? '<i class="fas fa-globe text-xs"></i>' : '<i class="fas fa-lock text-xs"></i>'} ${room.name || 'Unnamed Room'}`;
          
          // Status badge
          const statusBadge = document.createElement('div');
          if (room.id === currentRoomId) {
            statusBadge.className = 'badge badge-sm badge-primary';
            statusBadge.textContent = 'Current';
          } else {
            statusBadge.className = 'badge badge-sm badge-ghost';
            statusBadge.textContent = `${clientCount} users`;
          }
          
          roomHeader.appendChild(roomNameEl);
          roomHeader.appendChild(statusBadge);
          roomContent.appendChild(roomHeader);
          
          // Room ID (show only if it's not the current room)
          if (room.id !== currentRoomId) {
            const roomIdEl = document.createElement('div');
            roomIdEl.className = 'text-xs opacity-60 mb-2 truncate';
            roomIdEl.textContent = `ID: ${room.id}`;
            roomContent.appendChild(roomIdEl);
          }
          
          // Join button (only if not current room)
          if (room.id !== currentRoomId) {
            const joinButton = document.createElement('button');
            joinButton.className = 'btn btn-primary btn-xs w-full mt-1';
            joinButton.innerHTML = '<i class="fas fa-sign-in-alt mr-1"></i> Join';
            joinButton.addEventListener('click', (e) => {
              e.stopPropagation(); // Prevent triggering the parent's click
              selectedRoomId = room.id;
              
              if (isPublic) {
                // Join public room directly
                const message = { 
                  type: 'join_room', 
                  roomId: room.id 
                };
                ws.send(JSON.stringify(message));
                logMessage('Joining public room', message);
              } else {
                // For private rooms, show the modal with password tab active
                document.getElementById('join-room-id').value = room.id;
                document.getElementById('password-tab').click();
                document.getElementById('join-private-modal').classList.add('modal-open');
              }
            });
            roomContent.appendChild(joinButton);
          }
          
          roomItem.appendChild(roomContent);
          roomList.appendChild(roomItem);
        });
      }
      
      // IMPROVED: Fixed startTimerInterval function to handle resuming from pause correctly and make animation smoother
      function startTimerInterval(timer) {
        if (timerIntervals[timer.id]) {
          clearInterval(timerIntervals[timer.id]);
        }
        if (timer.status !== 'running') return;
        
        const remaining = timer.remaining; // seconds
        const startTime = Date.now();
        const totalDuration = timer.duration * 1000; // convert to ms
        const remainingMs = remaining * 1000; // convert to ms
        
        // Update more frequently for smoother animation (every 16ms â‰ˆ 60fps)
        timerIntervals[timer.id] = setInterval(() => {
          const elapsedMs = Date.now() - startTime;
          const remainingTimeMs = Math.max(0, remainingMs - elapsedMs);
          const newRemaining = Math.ceil(remainingTimeMs / 1000); // Round up to nearest second for display
          
          // For progress bar, use precise ms values for smooth animation
          const preciseRemaining = remainingTimeMs / 1000; // seconds with decimal precision
          
          // Update only this timer's display without re-rendering the whole list
          updateTimerDisplay({ 
            ...timer, 
            remaining: newRemaining,
            preciseRemaining: preciseRemaining // Add precise value for smoother progress
          });
          
          if (remainingTimeMs <= 0) {
            clearInterval(timerIntervals[timer.id]);
            delete timerIntervals[timer.id];
            // Mark as completed and update UI
            updateTimerDisplay({ 
              ...timer, 
              remaining: 0,
              status: 'completed'
            });
            // Send completed notification to server
            if (ws && ws.readyState === WebSocket.OPEN) {
              ws.send(JSON.stringify({ 
                type: 'timer_completed', 
                timerId: timer.id 
              }));
            }
          }
        }, 16); // ~60fps for smooth animation
      }
      
      // IMPROVED: renderTimerList function to maintain individual timer state
      function renderTimerList() {
        timerList.innerHTML = '';
        if (!currentRoomId) {
          const emptyItem = document.createElement('div');
          emptyItem.className = 'p-2 bg-gray-700 rounded text-sm sm:text-base';
          emptyItem.textContent = 'Join a room to see timers';
          timerList.appendChild(emptyItem);
          return;
        }
        if (roomTimers.length === 0) {
          const emptyItem = document.createElement('div');
          emptyItem.className = 'p-2 bg-gray-700 rounded text-sm sm:text-base';
          emptyItem.textContent = 'No timers in this room';
          timerList.appendChild(emptyItem);
          return;
        }
        
        // Save current intervals before rebuilding
        const runningTimerIds = Object.keys(timerIntervals);
        
        roomTimers.forEach(timer => {
          // If timer is completed or created, change its status to "ready"
          // This ensures timers show as "ready" instead of "completed"
          if (timer.status === 'completed' || timer.status === 'created') {
            timer.status = 'ready';
            timer.remaining = timer.duration; // Reset remaining time to full
          }
          
          const timerItem = document.createElement('div');
          timerItem.className = 'p-2 sm:p-4 bg-gray-700 rounded mb-2 text-sm sm:text-base';
          timerItem.setAttribute('data-timer-id', timer.id);
          
          // Header with timer name and status badge
          const headerDiv = document.createElement('div');
          headerDiv.className = 'flex items-center justify-between mb-1';
          headerDiv.innerHTML = `<strong class="truncate mr-1">${timer.name}</strong> <span class="timer-status">${getStatusBadge(timer.status)}</span>`;
          
          // Progress bar
          const progressContainer = document.createElement('div');
          progressContainer.className = 'w-full bg-gray-600 rounded h-2 sm:h-4 my-1 sm:my-2';
          const progressBar = document.createElement('div');
          progressBar.className = 'bg-primary h-2 sm:h-4 rounded';
          progressBar.style.transition = 'width 1s linear';
          
          // Set initial progress bar width based on status
          let progressPercent;
          if (timer.status === 'running') {
            progressPercent = Math.max(0, Math.min(100, (timer.remaining / timer.duration) * 100));
          } else if (timer.status === 'ready') {
            progressPercent = 100; // Full bar for ready state
          } else if (timer.status === 'paused') {
            progressPercent = Math.max(0, Math.min(100, (timer.remaining / timer.duration) * 100));
          } else {
            progressPercent = 100; // Default to full bar
          }
          
          progressBar.style.width = `${progressPercent}%`;
          progressContainer.appendChild(progressBar);
          
          // Timer details
          const detailsDiv = document.createElement('div');
          detailsDiv.className = 'flex justify-between text-xs sm:text-sm';
          detailsDiv.innerHTML = `<div>Total: ${formatTime(timer.duration)}</div><div class="timer-remaining">${formatTime(timer.remaining)}</div>`;
          
          // Controls: toggle (start/pause) and reset
          const controlsDiv = document.createElement('div');
          controlsDiv.className = 'flex gap-1 sm:gap-2 mt-2';

          // Single toggle button for start/pause
          const toggleBtn = document.createElement('button');
          if (timer.status === 'running') {
            toggleBtn.innerHTML = '<i class="fas fa-pause sm:mr-1"></i><span class="hidden sm:inline">Pause</span>';
            toggleBtn.className = 'btn btn-warning btn-xs sm:btn-sm flex-1';
            toggleBtn.setAttribute('data-action', 'pause');
          } else {
            toggleBtn.innerHTML = '<i class="fas fa-play sm:mr-1"></i><span class="hidden sm:inline">Start</span>';
            toggleBtn.className = 'btn btn-success btn-xs sm:btn-sm flex-1';
            toggleBtn.setAttribute('data-action', 'start');
          }
          
          toggleBtn.addEventListener('click', (e) => {
            e.stopPropagation(); // Prevent event bubbling
            const action = toggleBtn.getAttribute('data-action');
            if (action === 'pause') {
              const message = { type: 'pause_timer', timerId: timer.id };
              ws.send(JSON.stringify(message));
              logMessage('Pausing timer', message);
            } else {
              const message = { type: 'start_timer', timerId: timer.id };
              ws.send(JSON.stringify(message));
              logMessage('Starting timer', message);
            }
          });

          const resetBtn = document.createElement('button');
          resetBtn.innerHTML = '<i class="fas fa-redo-alt sm:mr-1"></i><span class="hidden sm:inline">Reset</span>';
          resetBtn.className = 'btn btn-error btn-xs sm:btn-sm flex-1';
          resetBtn.addEventListener('click', (e) => {
            e.stopPropagation(); // Prevent event bubbling
            const message = { type: 'stop_timer', timerId: timer.id };
            ws.send(JSON.stringify(message));
            logMessage('Resetting timer', message);
          });

          // Add a delete button
          const deleteBtn = document.createElement('button');
          deleteBtn.innerHTML = '<i class="fas fa-trash-alt sm:mr-1"></i><span class="hidden sm:inline">Delete</span>';
          deleteBtn.className = 'btn btn-outline btn-error btn-xs sm:btn-sm flex-1';
          deleteBtn.addEventListener('click', (e) => {
            e.stopPropagation(); // Prevent event bubbling
            if (confirm('Are you sure you want to delete this timer?')) {
              const message = { type: 'delete_timer', timerId: timer.id };
              ws.send(JSON.stringify(message));
              logMessage('Deleting timer', message);
            }
          });

          controlsDiv.appendChild(toggleBtn);
          controlsDiv.appendChild(resetBtn);
          controlsDiv.appendChild(deleteBtn);
          
          timerItem.appendChild(headerDiv);
          timerItem.appendChild(progressContainer);
          timerItem.appendChild(detailsDiv);
          timerItem.appendChild(controlsDiv);
          
          timerList.appendChild(timerItem);
          
          // Start an interval if timer is running
          if (timer.status === 'running') {
            // Only start a new interval if it wasn't already running
            if (!runningTimerIds.includes(timer.id.toString())) {
              startTimerInterval(timer);
            }
          }
        });
      }
      
      // IMPROVED: updateTimerDisplay function to only update a specific timer
      function updateTimerDisplay(timer) {
        const timerElement = document.querySelector(`[data-timer-id="${timer.id}"]`);
        if (!timerElement) return;
        
        const progressBar = timerElement.querySelector('.bg-primary');
        const remainingTimeElement = timerElement.querySelector('.timer-remaining');
        const statusElement = timerElement.querySelector('.timer-status');
        
        // If timer is at 0 remaining, automatically set status to completed
        if (timer.remaining <= 0 && timer.status === 'running') {
          timer.status = 'completed';
          if (timerIntervals[timer.id]) {
            clearInterval(timerIntervals[timer.id]);
            delete timerIntervals[timer.id];
          }
        }
        
        // Set progress bar based on status
        let progressPercent;
        if (timer.status === 'running') {
          // For running timers, use precise remaining time if available (for smoother animation)
          if (timer.hasOwnProperty('preciseRemaining')) {
            progressPercent = Math.max(0, Math.min(100, (timer.preciseRemaining / timer.duration) * 100));
          } else {
            progressPercent = Math.max(0, Math.min(100, (timer.remaining / timer.duration) * 100));
          }
        } else if (timer.status === 'completed' || timer.status === 'ready') {
          // For completed or ready timers, show full bar
          progressPercent = 100;
        } else {
          // For all other statuses (created, paused), show percentage
          progressPercent = Math.max(0, Math.min(100, (timer.remaining / timer.duration) * 100));
        }
        
        progressBar.style.width = `${progressPercent}%`;
        
        // Add high-quality animation for running timers
        if (timer.status === 'running') {
          progressBar.style.transition = 'width 1s linear';
        } else {
          progressBar.style.transition = 'width 0.3s ease';
        }
        remainingTimeElement.textContent = formatTime(timer.remaining);
        
        // Update status
        if (statusElement.innerHTML !== getStatusBadge(timer.status)) {
          statusElement.innerHTML = getStatusBadge(timer.status);
        }
        
        // Update the toggle button based on status
        const toggleBtn = timerElement.querySelector('button[data-action]');
        if (toggleBtn) {
          const currentAction = toggleBtn.getAttribute('data-action');
          const newAction = timer.status === 'running' ? 'pause' : 'start';
          
          if (currentAction !== newAction) {
            if (timer.status === 'running') {
              toggleBtn.innerHTML = '<i class="fas fa-pause sm:mr-1"></i><span class="hidden sm:inline">Pause</span>';
              toggleBtn.className = 'btn btn-warning btn-xs sm:btn-sm flex-1';
              toggleBtn.setAttribute('data-action', 'pause');
            } else {
              toggleBtn.innerHTML = '<i class="fas fa-play sm:mr-1"></i><span class="hidden sm:inline">Start</span>';
              toggleBtn.className = 'btn btn-success btn-xs sm:btn-sm flex-1';
              toggleBtn.setAttribute('data-action', 'start');
            }
          }
        }
      }
      
      function updateUIForRoomJoined(room) {
        currentRoomId = room.id;
        currentRoomName.textContent = room.name;
        currentRoomIdElement.textContent = room.id;
        currentRoomToken.textContent = room.invite_token || 'None';
        roomDetails.classList.remove('hidden');
        leaveRoomBtn.disabled = false;
        createTimerBtn.disabled = false;
        
        // Close the modal if it's open
        joinPrivateModal.classList.remove('modal-open');
        
        // Update room list to show current room
        document.querySelectorAll('[data-room-id].selected-room, [data-room-id].current-room').forEach(el => {
          el.classList.remove('selected-room');
          el.classList.remove('current-room');
        });
        
        const currentRoomElement = document.querySelector(`[data-room-id="${room.id}"]`);
        if (currentRoomElement) {
          currentRoomElement.classList.add('current-room');
        }
        
        // If this is a private room that's not in our list, add it
        const isInList = availableRooms.some(r => r.id === room.id);
        if (!isInList) {
          availableRooms.push(room);
          displayRooms(availableRooms);
        }
      }
      
      function updateUIForRoomLeft() {
        currentRoomId = null;
        currentRoomName.textContent = 'None';
        roomDetails.classList.add('hidden');
        leaveRoomBtn.disabled = true;
        createTimerBtn.disabled = true;
        selectedRoomId = null;
        roomTimers = [];
        renderTimerList();
        
        // Clear any active timers
        Object.keys(timerIntervals).forEach(timerId => {
          clearInterval(timerIntervals[timerId]);
          delete timerIntervals[timerId];
        });
        
        // Update the room list to reflect that we're not in any room
        document.querySelectorAll('[data-room-id].current-room').forEach(el => {
          el.classList.remove('current-room');
        });
      }
      
      // WebSocket connection handling
      function connectToServer() {
        const serverUrl = serverUrlInput.value.trim();
        if (!serverUrl) {
          alert('Please enter a valid WebSocket server URL');
          return;
        }
        try {
          updateConnectionStatus('Connecting...');
          ws = new WebSocket(serverUrl);
          ws.onopen = () => {
            updateConnectionStatus('Connected');
            logMessage('Connected to server');
            connectBtn.disabled = true;
            disconnectBtn.disabled = false;
            createRoomBtn.disabled = false;
          };
          ws.onclose = () => {
            updateConnectionStatus('Disconnected');
            logMessage('Disconnected from server');
            connectBtn.disabled = false;
            disconnectBtn.disabled = true;
            createRoomBtn.disabled = true;
            leaveRoomBtn.disabled = true;
            createTimerBtn.disabled = true;
            updateUIForRoomLeft();
            Object.keys(timerIntervals).forEach(timerId => {
              clearInterval(timerIntervals[timerId]);
              delete timerIntervals[timerId];
            });
          };
          ws.onerror = (error) => {
            updateConnectionStatus('Error');
            logMessage('WebSocket error', 'Connection failed.');
            alert('Failed to connect to the WebSocket server.');
          };
          ws.onmessage = (event) => {
            try {
              const message = JSON.parse(event.data);
              logMessage('Received message', message);
              switch(message.type) {
                case 'available_rooms':
                  availableRooms = message.rooms || [];
                  displayRooms(availableRooms);
                  break;
                case 'room_created':
                  logMessage('Room created successfully', message.room);
                  updateUIForRoomJoined(message.room);
                  break;
                case 'room_joined':
                  logMessage('Joined room', message.room);
                  updateUIForRoomJoined(message.room);
                  roomTimers = message.timers || [];
                  renderTimerList();
                  break;
                case 'room_left':
                  logMessage('Left room');
                  updateUIForRoomLeft();
                  break;
                case 'timer_list':
                  roomTimers = message.timers || [];
                  renderTimerList();
                  break;
                case 'timer_created':
                  logMessage('Timer created', message.timer);
                  roomTimers.push(message.timer);
                  renderTimerList();
                  break;
                  
                // IMPROVED: Updated WebSocket handlers for timer events  
                case 'timer_started':
                  logMessage('Timer started', message.timer);
                  const startedTimer = message.timer;
                  // Update the timer in our list
                  roomTimers = roomTimers.map(t => t.id === startedTimer.id ? startedTimer : t);
                  // Find the DOM element and update it directly
                  updateTimerDisplay(startedTimer);
                  // Start the timer interval
                  startTimerInterval(startedTimer);
                  break;

                case 'timer_paused':
                  logMessage('Timer paused', message.timer);
                  const pausedTimer = message.timer;
                  // Clear the interval
                  if (timerIntervals[pausedTimer.id]) {
                    clearInterval(timerIntervals[pausedTimer.id]);
                    delete timerIntervals[pausedTimer.id];
                  }
                  // Update the timer in our list
                  roomTimers = roomTimers.map(t => t.id === pausedTimer.id ? pausedTimer : t);
                  // Find the DOM element and update it directly
                  updateTimerDisplay(pausedTimer);
                  break;

                // ADDED: Handler for timer_stopped response from server
                case 'timer_stopped':
                  logMessage('Timer stopped/reset', message.timer);
                  const stoppedTimer = message.timer;
                  // Clear the interval
                  if (timerIntervals[stoppedTimer.id]) {
                    clearInterval(timerIntervals[stoppedTimer.id]);
                    delete timerIntervals[stoppedTimer.id];
                  }
                  // Mark as ready instead of completed, with full remaining time
                  stoppedTimer.status = 'ready';
                  stoppedTimer.remaining = stoppedTimer.duration;
                  // Update the timer in our list
                  roomTimers = roomTimers.map(t => t.id === stoppedTimer.id ? stoppedTimer : t);
                  // Find the DOM element and update it directly
                  updateTimerDisplay(stoppedTimer);
                  break;

                case 'timer_completed':
                  logMessage('Timer completed', message.timer);
                  const completedTimer = message.timer;
                  // Clear the interval
                  if (timerIntervals[completedTimer.id]) {
                    clearInterval(timerIntervals[completedTimer.id]);
                    delete timerIntervals[completedTimer.id];
                  }
                  // Mark as ready instead of completed, with full remaining time
                  completedTimer.status = 'ready';
                  completedTimer.remaining = completedTimer.duration;
                  // Update the timer in our list
                  roomTimers = roomTimers.map(t => t.id === completedTimer.id ? completedTimer : t);
                  // Find the DOM element and update it directly
                  updateTimerDisplay(completedTimer);
                  break;
                  
                case 'timer_deleted':
                  logMessage('Timer deleted', message);
                  // Remove the timer from the list
                  if (message.timerId) {
                    // Clear any running interval for this timer
                    if (timerIntervals[message.timerId]) {
                      clearInterval(timerIntervals[message.timerId]);
                      delete timerIntervals[message.timerId];
                    }
                    // Filter out the deleted timer
                    roomTimers = roomTimers.filter(t => t.id !== message.timerId);
                    // Re-render the timer list
                    renderTimerList();
                  }
                  break;
                case 'ping':
                  logMessage('Received ping from server');
                  if (ws && ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({ type: 'pong' }));
                    logMessage('Sent pong response');
                  }
                  break;
                case 'pong':
                  logMessage('Received pong from server');
                  break;
                case 'error':
                  logMessage('Error from server', message);
                  alert(`Server error: ${message.message}`);
                  break;
                default:
                  logMessage('Unknown message type', message);
              }
            } catch (error) {
              logMessage('Error parsing message', error.message);
            }
          };
          const pingInterval = setInterval(() => {
            if (ws && ws.readyState === WebSocket.OPEN) {
              ws.send(JSON.stringify({ type: 'ping' }));
              logMessage('Sent ping to server');
            } else {
              clearInterval(pingInterval);
            }
          }, 20000);
        } catch (error) {
          updateConnectionStatus('Error');
          logMessage('Connection error', error.message);
        }
      }
      
      function disconnectFromServer() {
        if (ws) {
          ws.close();
          ws = null;
        }
      }
      
      // Event listeners
      connectBtn.addEventListener('click', connectToServer);
      disconnectBtn.addEventListener('click', disconnectFromServer);
      
      // Create room event
      createRoomBtn.addEventListener('click', () => {
        if (!ws || ws.readyState !== WebSocket.OPEN) {
          alert('Not connected to server');
          return;
        }
        const roomName = roomNameInput.value.trim();
        if (!roomName) {
          alert('Please enter a room name');
          return;
        }
        const message = {
          type: 'create_room',
          name: roomName,
          isPublic: roomPublicCheckbox.checked
        };
        const password = roomPasswordInput.value.trim();
        if (password) {
          message.password = password;
        }
        ws.send(JSON.stringify(message));
        logMessage('Creating room', message);
      });
      
      // Join private room button event (open modal)
      joinPrivateBtn.addEventListener('click', () => {
        joinPrivateModal.classList.add('modal-open');
        inviteTab.click(); // Default to invite tab
      });
      
      // Close modal when backdrop is clicked or cancel button is pressed
      modalBackdrop.addEventListener('click', () => {
        joinPrivateModal.classList.remove('modal-open');
      });
      
      cancelJoinBtn.addEventListener('click', () => {
        joinPrivateModal.classList.remove('modal-open');
      });
      
      // Tab switching in the modal
      inviteTab.addEventListener('click', () => {
        inviteTab.classList.add('tab-active');
        passwordTab.classList.remove('tab-active');
        invitePanel.classList.remove('hidden');
        passwordPanel.classList.add('hidden');
      });
      
      passwordTab.addEventListener('click', () => {
        passwordTab.classList.add('tab-active');
        inviteTab.classList.remove('tab-active');
        passwordPanel.classList.remove('hidden');
        invitePanel.classList.add('hidden');
      });
      
      // Join private room from modal
      joinPrivateRoomBtn.addEventListener('click', () => {
        if (!ws || ws.readyState !== WebSocket.OPEN) {
          alert('Not connected to server');
          return;
        }
        
        // Check which tab is active
        const isInviteActive = inviteTab.classList.contains('tab-active');
        
        if (isInviteActive) {
          // Join via invite token
          const inviteToken = joinInviteTokenInput.value.trim();
          if (!inviteToken) {
            alert('Please enter an invite token');
            return;
          }
          
          const message = {
            type: 'join_room',
            inviteToken: inviteToken
          };
          ws.send(JSON.stringify(message));
          logMessage('Joining room via invite token', message);
        } else {
          // Join via room ID and password
          const roomId = joinRoomIdInput.value.trim();
          const password = joinRoomPasswordInput.value.trim();
          
          if (!roomId) {
            alert('Please enter a room ID');
            return;
          }
          
          const message = {
            type: 'join_room',
            roomId: roomId
          };
          
          if (password) {
            message.password = password;
          }
          
          ws.send(JSON.stringify(message));
          logMessage('Joining room via ID and password', message);
        }
      });
      
      // Leave room
      leaveRoomBtn.addEventListener('click', () => {
        if (!ws || ws.readyState !== WebSocket.OPEN) {
          alert('Not connected to server');
          return;
        }
        if (!currentRoomId) {
          alert('Not in a room');
          return;
        }
        ws.send(JSON.stringify({ type: 'leave_room' }));
        logMessage('Leaving room');
      });
      
      createTimerBtn.addEventListener('click', () => {
        if (!ws || ws.readyState !== WebSocket.OPEN) {
          alert('Not connected to server');
          return;
        }
        if (!currentRoomId) {
          alert('Not in a room');
          return;
        }
        const timerName = timerNameInput.value.trim();
        if (!timerName) {
          alert('Please enter a timer name');
          return;
        }
        const timerDuration = parseInt(timerDurationInput.value);
        if (isNaN(timerDuration) || timerDuration <= 0) {
          alert('Please enter a valid duration');
          return;
        }
        const message = {
          type: 'create_timer',
          name: timerName,
          duration: timerDuration
        };
        ws.send(JSON.stringify(message));
        logMessage('Creating timer', message);
      });
      
      if (serverUrlInput.value) {
        connectBtn.click();
      }
    }
  </script>
</body>
</html>
