<!DOCTYPE html>
<html lang="en" data-theme="night">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Timer App Client</title>
  <!-- Load Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Load DaisyUI from CDN -->
  <link href="https://cdn.jsdelivr.net/npm/daisyui@2.51.5/dist/full.css" rel="stylesheet">
  <!-- Load Font Awesome for icons -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css">
  <style>
    /* Custom styles for dark theme selections and disabled buttons */
    .selected-room {
      background-color: #374151 !important; /* Tailwind gray-700 */
      border-left: 4px solid #1e293b !important; /* Tailwind blue-gray-800 */
    }
    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }
    /* Mobile overflow fixes */
    @media (max-width: 640px) {
      .mobile-container {
        max-width: 100%;
        padding: 0.5rem;
      }
      .mobile-input {
        font-size: 16px; /* Prevent iOS zoom on focus */
      }
    }
  </style>
</head>
<body class="bg-gray-900 text-gray-100 p-2 sm:p-4 md:p-8 w-full">
  <div class="max-w-5xl mx-auto">
    <h1 class="text-2xl sm:text-3xl font-bold text-gray-100 mb-4 text-center sm:text-left">Timer App</h1>
    
    <div id="connection-status" class="alert alert-error mb-4 text-center text-sm sm:text-base">
      Disconnected
    </div>
    
    <div class="mb-4">
      <label for="server-url" class="label text-sm sm:text-base">WebSocket Server URL</label>
      <div class="flex flex-wrap gap-2">
        <input type="text" id="server-url" value="wss://simple-timers-wss.onrender.com" placeholder="ws://localhost:8080" class="input input-bordered flex-1 bg-gray-800 border-gray-700 text-gray-100 text-sm sm:text-base mobile-input">
        <div class="flex gap-1">
          <button id="connect-btn" class="btn btn-primary btn-sm sm:btn-md">
            <i class="fas fa-plug sm:mr-1"></i>
            <span class="hidden sm:inline">Connect</span>
          </button>
          <button id="disconnect-btn" class="btn btn-primary btn-sm sm:btn-md" disabled>
            <i class="fas fa-power-off sm:mr-1"></i>
            <span class="hidden sm:inline">Disconnect</span>
          </button>
        </div>
      </div>
    </div>
    
    <!-- Responsive container: stacks on mobile, side-by-side on md+ -->
    <div class="flex flex-col md:flex-row gap-4">
      <!-- Left Panel: Rooms -->
      <div class="flex-1 card bg-gray-800 shadow p-3 sm:p-6 w-full">
        <h2 class="card-title text-lg sm:text-xl mb-2 sm:mb-4">Rooms</h2>
        
        <div class="collapse collapse-arrow mb-4">
          <input type="checkbox" class="peer"> 
          <div class="collapse-title bg-gray-700 rounded-lg text-base sm:text-lg font-semibold">
            Create Room
          </div>
          <div class="collapse-content bg-gray-700 rounded-b-lg pt-2"> 
            <div id="create-room-form" class="p-2">
              <div class="mb-2 sm:mb-4">
                <label for="room-name" class="label text-sm sm:text-base p-1">Room Name</label>
                <input type="text" id="room-name" placeholder="My Room" class="input input-bordered w-full bg-gray-600 border-gray-600 text-gray-100 h-8 sm:h-10 text-sm sm:text-base mobile-input">
              </div>
              <div class="mb-2 sm:mb-4">
                <label for="room-password" class="label text-sm sm:text-base p-1">Password (optional)</label>
                <input type="password" id="room-password" placeholder="Leave empty for no password" class="input input-bordered w-full bg-gray-600 border-gray-600 text-gray-100 h-8 sm:h-10 text-sm sm:text-base mobile-input">
              </div>
              <div class="form-control mb-2 sm:mb-4">
                <label class="cursor-pointer label justify-start gap-2">
                  <input type="checkbox" id="room-public" class="checkbox checkbox-sm sm:checkbox-md" checked>
                  <span class="label-text text-sm sm:text-base">Public Room</span> 
                </label>
              </div>
              <button id="create-room-btn" class="btn btn-primary btn-sm sm:btn-md w-full" disabled>Create Room</button>
            </div>
          </div>
        </div>
        
        <div class="collapse collapse-arrow mb-4">
          <input type="checkbox" class="peer"> 
          <div class="collapse-title bg-gray-700 rounded-lg text-base sm:text-lg font-semibold">
            Join Room
          </div>
          <div class="collapse-content bg-gray-700 rounded-b-lg pt-2">
            <div id="join-room-form" class="p-2">
              <div class="mb-2 sm:mb-4">
                <label for="join-room-password" class="label text-sm sm:text-base p-1">Password (if required)</label>
                <input type="password" id="join-room-password" placeholder="Enter room password" class="input input-bordered w-full bg-gray-600 border-gray-600 text-gray-100 h-8 sm:h-10 text-sm sm:text-base mobile-input">
              </div>
              <div class="mb-2 sm:mb-4">
                <label for="join-invite-token" class="label text-sm sm:text-base p-1">Invite Token (if available)</label>
                <input type="text" id="join-invite-token" placeholder="Enter invite token" class="input input-bordered w-full bg-gray-600 border-gray-600 text-gray-100 h-8 sm:h-10 text-sm sm:text-base mobile-input">
              </div>
              <div class="flex gap-2 flex-wrap">
                <button id="join-room-btn" class="btn btn-primary btn-sm sm:btn-md flex-1" disabled>
                  <i class="fas fa-sign-in-alt sm:mr-1"></i>
                  <span class="hidden sm:inline">Join</span>
                </button>
                <button id="leave-room-btn" class="btn btn-primary btn-sm sm:btn-md flex-1" disabled>
                  <i class="fas fa-sign-out-alt sm:mr-1"></i>
                  <span class="hidden sm:inline">Leave</span>
                </button>
              </div>
            </div>
          </div>
        </div>
        
        <h3 class="text-base sm:text-lg font-semibold mb-2">Available Rooms</h3>
        <div id="room-list" class="max-h-48 sm:max-h-72 overflow-y-auto rounded-lg">
          <div class="p-2 bg-gray-700 rounded text-sm sm:text-base">Loading rooms...</div>
        </div>
      </div>
      
      <!-- Right Panel: Timers -->
      <div class="flex-1 card bg-gray-800 shadow p-3 sm:p-6 w-full">
        <div id="current-room-info" class="mb-3 sm:mb-6">
          <h2 class="text-lg sm:text-xl font-semibold mb-2">
            <i class="fas fa-home sm:mr-1"></i> Current Room: <span id="current-room-name" class="font-normal">None</span>
          </h2>
          <div id="room-details" class="bg-gray-700 p-2 sm:p-4 rounded text-sm sm:text-base hidden">
            <div class="mb-1"><strong>Room ID:</strong> <span id="current-room-id" class="break-all"></span></div>
            <div><strong>Invite Token:</strong> <span id="current-room-token" class="break-all"></span></div>
          </div>
        </div>
        
        <div class="collapse collapse-arrow mb-4">
          <input type="checkbox" class="peer"> 
          <div class="collapse-title bg-gray-700 rounded-lg text-base sm:text-lg font-semibold">
            Create Timer
          </div>
          <div class="collapse-content bg-gray-700 rounded-b-lg pt-2">
            <div id="create-timer-form" class="p-2">
              <div class="mb-2 sm:mb-4">
                <label for="timer-name" class="label text-sm sm:text-base p-1">Timer Name</label>
                <input type="text" id="timer-name" placeholder="My Timer" class="input input-bordered w-full bg-gray-600 border-gray-600 text-gray-100 h-8 sm:h-10 text-sm sm:text-base mobile-input">
              </div>
              <div class="mb-2 sm:mb-4">
                <label for="timer-duration" class="label text-sm sm:text-base p-1">Duration (seconds)</label>
                <input type="number" id="timer-duration" value="60" min="1" class="input input-bordered w-full bg-gray-600 border-gray-600 text-gray-100 h-8 sm:h-10 text-sm sm:text-base mobile-input">
              </div>
              <button id="create-timer-btn" class="btn btn-primary btn-sm sm:btn-md w-full" disabled>
                <i class="fas fa-plus-circle sm:mr-1"></i>
                <span class="inline sm:inline">Create Timer</span>
              </button>
            </div>
          </div>
        </div>
        
        <h3 class="text-base sm:text-lg font-semibold mb-2">Active Timers</h3>
        <div id="timer-list" class="max-h-48 sm:max-h-72 overflow-y-auto rounded-lg">
          <div class="p-2 bg-gray-700 rounded text-sm sm:text-base">Join a room to see timers</div>
        </div>
      </div>
    </div>
    
    <div class="collapse collapse-arrow mt-4">
      <input type="checkbox" class="peer"> 
      <div class="collapse-title bg-gray-800 rounded-lg text-base sm:text-lg font-semibold">
        Connection Log
      </div>
      <div class="collapse-content bg-gray-800 rounded-b-lg pt-2">
        <div id="log-container" class="bg-gray-700 border border-gray-700 rounded p-2 sm:p-4 max-h-32 sm:max-h-40 overflow-y-auto">
          <div class="font-mono text-xs sm:text-sm">Waiting for connection...</div>
        </div>
      </div>
    </div>
  </div>
  
  <script>
    document.addEventListener('DOMContentLoaded', function() {
      console.log('DOM fully loaded - starting application');
      initializeApp();
    });
    
    function initializeApp() {
      // Global variables
      let ws = null;
      let selectedRoomId = null;
      let currentRoomId = null;
      let availableRooms = [];
      let roomTimers = [];
      let timerIntervals = {};
      
      // DOM elements
      const connectBtn = document.getElementById('connect-btn');
      const disconnectBtn = document.getElementById('disconnect-btn');
      const serverUrlInput = document.getElementById('server-url');
      const connectionStatus = document.getElementById('connection-status');
      const logContainer = document.getElementById('log-container');
      
      const roomNameInput = document.getElementById('room-name');
      const roomPasswordInput = document.getElementById('room-password');
      const roomPublicCheckbox = document.getElementById('room-public');
      const createRoomBtn = document.getElementById('create-room-btn');
      
      const joinRoomPasswordInput = document.getElementById('join-room-password');
      const joinInviteTokenInput = document.getElementById('join-invite-token');
      const joinRoomBtn = document.getElementById('join-room-btn');
      const leaveRoomBtn = document.getElementById('leave-room-btn');
      
      const roomList = document.getElementById('room-list');
      const currentRoomName = document.getElementById('current-room-name');
      const currentRoomIdElement = document.getElementById('current-room-id');
      const currentRoomToken = document.getElementById('current-room-token');
      const roomDetails = document.getElementById('room-details');
      
      const timerNameInput = document.getElementById('timer-name');
      const timerDurationInput = document.getElementById('timer-duration');
      const createTimerBtn = document.getElementById('create-timer-btn');
      
      const timerList = document.getElementById('timer-list');
      
      // Helper functions
      function logMessage(message, data = null) {
        const now = new Date().toLocaleTimeString();
        const logEntry = document.createElement('div');
        logEntry.className = 'font-mono text-xs sm:text-sm';
        logEntry.textContent = data ? `[${now}] ${message}: ${JSON.stringify(data, null, 2)}` : `[${now}] ${message}`;
        logContainer.appendChild(logEntry);
        logContainer.scrollTop = logContainer.scrollHeight;
      }
      
      function updateConnectionStatus(status) {
        connectionStatus.textContent = status;
        if (status.toLowerCase() === 'connected') {
          connectionStatus.className = 'alert alert-success mb-4 text-center text-sm sm:text-base';
        } else if (status.toLowerCase() === 'connecting') {
          connectionStatus.className = 'alert alert-warning mb-4 text-center text-sm sm:text-base';
        } else {
          connectionStatus.className = 'alert alert-error mb-4 text-center text-sm sm:text-base';
        }
      }
      
      function formatTime(seconds) {
        const minutes = Math.floor(seconds / 60);
        const remainingSeconds = seconds % 60;
        return `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
      }
      
      function getStatusBadge(status) {
        switch(status) {
          case 'created': return '<span class="badge badge-xs sm:badge-sm badge-info">Created</span>';
          case 'running': return '<span class="badge badge-xs sm:badge-sm badge-success">Running</span>';
          case 'paused': return '<span class="badge badge-xs sm:badge-sm badge-warning">Paused</span>';
          case 'completed': return '<span class="badge badge-xs sm:badge-sm badge-error">Completed</span>';
          default: return `<span class="badge badge-xs sm:badge-sm">${status}</span>`;
        }
      }
      
      function displayRooms(rooms) {
        roomList.innerHTML = '';
        if (!rooms || rooms.length === 0) {
          const emptyItem = document.createElement('div');
          emptyItem.className = 'p-2 bg-gray-700 rounded text-sm sm:text-base';
          emptyItem.textContent = 'No rooms available';
          roomList.appendChild(emptyItem);
          return;
        }
        rooms.forEach(room => {
          const roomItem = document.createElement('div');
          roomItem.className = 'p-2 bg-gray-700 rounded mb-1 cursor-pointer hover:bg-gray-600 text-sm sm:text-base';
          if (selectedRoomId === room.id) {
            roomItem.classList.add('selected-room');
          }
          roomItem.setAttribute('data-room-id', room.id);
          
          const roomName = document.createElement('div');
          roomName.innerHTML = `<strong>${room.name || 'Unnamed Room'}</strong>`;
          
          const roomInfo = document.createElement('div');
          const isPublic = room.is_public === 1 || room.is_public === true;
          const clientCount = room.client_count || 0;
          roomInfo.textContent = `${isPublic ? 'ðŸŒ Public' : 'ðŸ”’ Private'} â€¢ ðŸ‘¥ ${clientCount}`;
          roomInfo.className = 'text-xs sm:text-sm opacity-80';
          
          roomItem.appendChild(roomName);
          roomItem.appendChild(roomInfo);
          
          roomItem.addEventListener('click', () => {
            document.querySelectorAll('[data-room-id].selected-room').forEach(el => {
              el.classList.remove('selected-room');
            });
            roomItem.classList.add('selected-room');
            selectedRoomId = room.id;
            joinRoomBtn.disabled = currentRoomId === selectedRoomId;
          });
          
          roomList.appendChild(roomItem);
        });
      }
      
      function renderTimerList() {
        timerList.innerHTML = '';
        if (!currentRoomId) {
          const emptyItem = document.createElement('div');
          emptyItem.className = 'p-2 bg-gray-700 rounded text-sm sm:text-base';
          emptyItem.textContent = 'Join a room to see timers';
          timerList.appendChild(emptyItem);
          return;
        }
        if (roomTimers.length === 0) {
          const emptyItem = document.createElement('div');
          emptyItem.className = 'p-2 bg-gray-700 rounded text-sm sm:text-base';
          emptyItem.textContent = 'No timers in this room';
          timerList.appendChild(emptyItem);
          return;
        }
        roomTimers.forEach(timer => {
          const timerItem = document.createElement('div');
          timerItem.className = 'p-2 sm:p-4 bg-gray-700 rounded mb-2 text-sm sm:text-base';
          timerItem.setAttribute('data-timer-id', timer.id);
          
          // Header with timer name and status badge
          const headerDiv = document.createElement('div');
          headerDiv.className = 'flex items-center justify-between mb-1';
          headerDiv.innerHTML = `<strong class="truncate mr-1">${timer.name}</strong> <span class="timer-status">${getStatusBadge(timer.status)}</span>`;
          
          // Progress bar
          const progressContainer = document.createElement('div');
          progressContainer.className = 'w-full bg-gray-600 rounded h-2 sm:h-4 my-1 sm:my-2';
          const progressBar = document.createElement('div');
          progressBar.className = 'bg-primary h-2 sm:h-4 rounded';
          const progressPercent = Math.max(0, Math.min(100, (timer.remaining / timer.duration) * 100));
          progressBar.style.width = `${progressPercent}%`;
          progressContainer.appendChild(progressBar);
          
          // Timer details
          const detailsDiv = document.createElement('div');
          detailsDiv.className = 'flex justify-between text-xs sm:text-sm';
          detailsDiv.innerHTML = `<div>Total: ${formatTime(timer.duration)}</div><div class="timer-remaining">${formatTime(timer.remaining)}</div>`;
          
          // Controls: toggle (start/pause) and reset
          const controlsDiv = document.createElement('div');
          controlsDiv.className = 'flex gap-1 sm:gap-2 mt-2';
          
          const toggleBtn = document.createElement('button');
          if (timer.status === 'running') {
            toggleBtn.innerHTML = '<i class="fas fa-pause sm:mr-1"></i><span class="hidden sm:inline">Pause</span>';
            toggleBtn.className = 'btn btn-warning btn-xs sm:btn-sm flex-1';
          } else {
            toggleBtn.innerHTML = '<i class="fas fa-play sm:mr-1"></i><span class="hidden sm:inline">Start</span>';
            toggleBtn.className = 'btn btn-success btn-xs sm:btn-sm flex-1';
          }
          toggleBtn.addEventListener('click', () => {
            if (toggleBtn.querySelector('.fa-pause')) {
              const message = { type: 'pause_timer', timerId: timer.id };
              ws.send(JSON.stringify(message));
              logMessage('Pausing timer', message);
            } else {
              const message = { type: 'start_timer', timerId: timer.id };
              ws.send(JSON.stringify(message));
              logMessage('Starting timer', message);
            }
          });
          
          const resetBtn = document.createElement('button');
          resetBtn.innerHTML = '<i class="fas fa-redo-alt sm:mr-1"></i><span class="hidden sm:inline">Reset</span>';
          resetBtn.className = 'btn btn-error btn-xs sm:btn-sm flex-1';
          resetBtn.addEventListener('click', () => {
            const message = { type: 'stop_timer', timerId: timer.id };
            ws.send(JSON.stringify(message));
            logMessage('Resetting timer', message);
          });
          
          controlsDiv.appendChild(toggleBtn);
          controlsDiv.appendChild(resetBtn);
          
          timerItem.appendChild(headerDiv);
          timerItem.appendChild(progressContainer);
          timerItem.appendChild(detailsDiv);
          timerItem.appendChild(controlsDiv);
          
          timerList.appendChild(timerItem);
          
          // Start an interval if timer is running and not already set
          if (timer.status === 'running' && !timerIntervals[timer.id]) {
            startTimerInterval(timer);
          }
        });
      }
      
      // Fixed: capture the paused remaining time so the timer resumes from where it left off.
      function startTimerInterval(timer) {
        if (timerIntervals[timer.id]) {
          clearInterval(timerIntervals[timer.id]);
        }
        if (timer.status !== 'running') return;
        
        let startRemaining = timer.remaining; // capture current remaining time at the moment of start
        const startTime = Date.now();
        timerIntervals[timer.id] = setInterval(() => {
          const elapsed = Math.floor((Date.now() - startTime) / 1000);
          const newRemaining = Math.max(0, startRemaining - elapsed);
          const updatedTimer = { ...timer, remaining: newRemaining };
          updateTimerDisplay(updatedTimer);
          if (newRemaining <= 0) {
            updatedTimer.status = 'completed';
            clearInterval(timerIntervals[timer.id]);
            delete timerIntervals[timer.id];
          }
        }, 1000);
      }
      
      function updateTimerDisplay(timer) {
        const timerElement = document.querySelector(`[data-timer-id="${timer.id}"]`);
        if (!timerElement) return;
        const progressBar = timerElement.querySelector('.bg-primary');
        const remainingTimeElement = timerElement.querySelector('.timer-remaining');
        const statusElement = timerElement.querySelector('.timer-status');
        
        const progressPercent = Math.max(0, Math.min(100, (timer.remaining / timer.duration) * 100));
        progressBar.style.width = `${progressPercent}%`;
        remainingTimeElement.textContent = formatTime(timer.remaining);
        statusElement.innerHTML = getStatusBadge(timer.status);
        
        const toggleBtn = timerElement.querySelector('button.btn-success, button.btn-warning');
        if (toggleBtn) {
          if (timer.status === 'running') {
            toggleBtn.innerHTML = '<i class="fas fa-pause sm:mr-1"></i><span class="hidden sm:inline">Pause</span>';
            toggleBtn.className = 'btn btn-warning btn-xs sm:btn-sm flex-1';
          } else {
            toggleBtn.innerHTML = '<i class="fas fa-play sm:mr-1"></i><span class="hidden sm:inline">Start</span>';
            toggleBtn.className = 'btn btn-success btn-xs sm:btn-sm flex-1';
          }
        }
      }
      
      function updateUIForRoomJoined(room) {
        currentRoomId = room.id;
        currentRoomName.textContent = room.name;
        currentRoomIdElement.textContent = room.id;
        currentRoomToken.textContent = room.invite_token || 'None';
        roomDetails.classList.remove('hidden');
        leaveRoomBtn.disabled = false;
        createTimerBtn.disabled = false;
        joinRoomBtn.disabled = true;
        document.querySelectorAll('[data-room-id].selected-room').forEach(el => {
          if (el.getAttribute('data-room-id') !== room.id) {
            el.classList.remove('selected-room');
          } else {
            el.classList.add('selected-room');
          }
        });
      }
      
      function updateUIForRoomLeft() {
        currentRoomId = null;
        currentRoomName.textContent = 'None';
        roomDetails.classList.add('hidden');
        leaveRoomBtn.disabled = true;
        createTimerBtn.disabled = true;
        joinRoomBtn.disabled = !selectedRoomId;
        roomTimers = [];
        renderTimerList();
        Object.keys(timerIntervals).forEach(timerId => {
          clearInterval(timerIntervals[timerId]);
          delete timerIntervals[timerId];
        });
      }
      
      // WebSocket connection handling
      function connectToServer() {
        const serverUrl = serverUrlInput.value.trim();
        if (!serverUrl) {
          alert('Please enter a valid WebSocket server URL');
          return;
        }
        try {
          updateConnectionStatus('Connecting...');
          ws = new WebSocket(serverUrl);
          ws.onopen = () => {
            updateConnectionStatus('Connected');
            logMessage('Connected to server');
            connectBtn.disabled = true;
            disconnectBtn.disabled = false;
            createRoomBtn.disabled = false;
          };
          ws.onclose = () => {
            updateConnectionStatus('Disconnected');
            logMessage('Disconnected from server');
            connectBtn.disabled = false;
            disconnectBtn.disabled = true;
            createRoomBtn.disabled = true;
            joinRoomBtn.disabled = true;
            leaveRoomBtn.disabled = true;
            createTimerBtn.disabled = true;
            updateUIForRoomLeft();
            Object.keys(timerIntervals).forEach(timerId => {
              clearInterval(timerIntervals[timerId]);
              delete timerIntervals[timerId];
            });
          };
          ws.onerror = (error) => {
            updateConnectionStatus('Error');
            logMessage('WebSocket error', 'Connection failed.');
            alert('Failed to connect to the WebSocket server.');
          };
          ws.onmessage = (event) => {
            try {
              const message = JSON.parse(event.data);
              logMessage('Received message', message);
              switch(message.type) {
                case 'available_rooms':
                  availableRooms = message.rooms || [];
                  displayRooms(availableRooms);
                  break;
                case 'room_created':
                  logMessage('Room created successfully', message.room);
                  updateUIForRoomJoined(message.room);
                  break;
                case 'room_joined':
                  logMessage('Joined room', message.room);
                  updateUIForRoomJoined(message.room);
                  roomTimers = message.timers || [];
                  renderTimerList();
                  break;
                case 'room_left':
                  logMessage('Left room');
                  updateUIForRoomLeft();
                  break;
                case 'timer_list':
                  roomTimers = message.timers || [];
                  renderTimerList();
                  break;
                case 'timer_created':
                  logMessage('Timer created', message.timer);
                  roomTimers.push(message.timer);
                  renderTimerList();
                  break;
                case 'timer_started':
                  logMessage('Timer started', message.timer);
                  roomTimers = roomTimers.map(t => t.id === message.timer.id ? message.timer : t);
                  renderTimerList();
                  break;
                case 'timer_paused':
                  logMessage('Timer paused', message.timer);
                  if (timerIntervals[message.timer.id]) {
                    clearInterval(timerIntervals[message.timer.id]);
                    delete timerIntervals[message.timer.id];
                  }
                  roomTimers = roomTimers.map(t => t.id === message.timer.id ? message.timer : t);
                  renderTimerList();
                  break;
                case 'timer_completed':
                  logMessage('Timer completed', message.timer);
                  if (timerIntervals[message.timer.id]) {
                    clearInterval(timerIntervals[message.timer.id]);
                    delete timerIntervals[message.timer.id];
                  }
                  roomTimers = roomTimers.map(t => t.id === message.timer.id ? message.timer : t);
                  renderTimerList();
                  break;
                case 'ping':
                  logMessage('Received ping from server');
                  if (ws && ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({ type: 'pong' }));
                    logMessage('Sent pong response');
                  }
                  break;
                case 'pong':
                  logMessage('Received pong from server');
                  break;
                case 'error':
                  logMessage('Error from server', message);
                  alert(`Server error: ${message.message}`);
                  break;
                default:
                  logMessage('Unknown message type', message);
              }
            } catch (error) {
              logMessage('Error parsing message', error.message);
            }
          };
          const pingInterval = setInterval(() => {
            if (ws && ws.readyState === WebSocket.OPEN) {
              ws.send(JSON.stringify({ type: 'ping' }));
              logMessage('Sent ping to server');
            } else {
              clearInterval(pingInterval);
            }
          }, 20000);
        } catch (error) {
          updateConnectionStatus('Error');
          logMessage('Connection error', error.message);
        }
      }
      
      function disconnectFromServer() {
        if (ws) {
          ws.close();
          ws = null;
        }
      }
      
      // Event listeners
      connectBtn.addEventListener('click', connectToServer);
      disconnectBtn.addEventListener('click', disconnectFromServer);
      
      createRoomBtn.addEventListener('click', () => {
        if (!ws || ws.readyState !== WebSocket.OPEN) {
          alert('Not connected to server');
          return;
        }
        const roomName = roomNameInput.value.trim();
        if (!roomName) {
          alert('Please enter a room name');
          return;
        }
        const message = {
          type: 'create_room',
          name: roomName,
          isPublic: roomPublicCheckbox.checked
        };
        const password = roomPasswordInput.value.trim();
        if (password) {
          message.password = password;
        }
        ws.send(JSON.stringify(message));
        logMessage('Creating room', message);
      });
      
      joinRoomBtn.addEventListener('click', () => {
        if (!ws || ws.readyState !== WebSocket.OPEN) {
          alert('Not connected to server');
          return;
        }
        if (!selectedRoomId) {
          alert('Please select a room to join');
          return;
        }
        const message = {
          type: 'join_room',
          roomId: selectedRoomId
        };
        const password = joinRoomPasswordInput.value.trim();
        if (password) {
          message.password = password;
        }
        const inviteToken = joinInviteTokenInput.value.trim();
        if (inviteToken) {
          message.inviteToken = inviteToken;
        }
        ws.send(JSON.stringify(message));
        logMessage('Joining room', message);
      });
      
      leaveRoomBtn.addEventListener('click', () => {
        if (!ws || ws.readyState !== WebSocket.OPEN) {
          alert('Not connected to server');
          return;
        }
        if (!currentRoomId) {
          alert('Not in a room');
          return;
        }
        ws.send(JSON.stringify({ type: 'leave_room' }));
        logMessage('Leaving room');
      });
      
      createTimerBtn.addEventListener('click', () => {
        if (!ws || ws.readyState !== WebSocket.OPEN) {
          alert('Not connected to server');
          return;
        }
        if (!currentRoomId) {
          alert('Not in a room');
          return;
        }
        const timerName = timerNameInput.value.trim();
        if (!timerName) {
          alert('Please enter a timer name');
          return;
        }
        const timerDuration = parseInt(timerDurationInput.value);
        if (isNaN(timerDuration) || timerDuration <= 0) {
          alert('Please enter a valid duration');
          return;
        }
        const message = {
          type: 'create_timer',
          name: timerName,
          duration: timerDuration
        };
        ws.send(JSON.stringify(message));
        logMessage('Creating timer', message);
      });
      
      if (serverUrlInput.value) {
        connectBtn.click();
      }
    }
  </script>
</body>
</html>
