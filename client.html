<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Timer App Client</title>
  <!-- Load Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Load DaisyUI from CDN -->
  <link href="https://cdn.jsdelivr.net/npm/daisyui@2.51.5/dist/full.css" rel="stylesheet">
</head>
<body class="bg-gray-100 p-4 md:p-8">
  <h1 class="text-3xl font-bold text-gray-800 mb-4">Timer App Test Client</h1>
  
  <div id="connection-status" class="alert alert-error mb-4 text-center">
    Disconnected
  </div>
  
  <div class="mb-4">
    <label for="server-url" class="label">WebSocket Server URL</label>
    <div class="flex gap-2">
      <input type="text" id="server-url" value="wss://simple-timers-wss.onrender.com" placeholder="ws://localhost:8080" class="input input-bordered flex-1">
      <button id="connect-btn" class="btn btn-primary">Connect</button>
      <button id="disconnect-btn" class="btn btn-primary" disabled>Disconnect</button>
    </div>
  </div>
  
  <!-- Responsive container: stacks on mobile, side-by-side on md+ -->
  <div class="flex flex-col md:flex-row gap-4">
    <!-- Left Panel: Rooms -->
    <div class="flex-1 card bg-white shadow p-6">
      <h2 class="card-title mb-4">Rooms</h2>
      
      <div id="create-room-form" class="mb-6">
        <h3 class="text-xl font-semibold mb-2">Create Room</h3>
        <div class="mb-4">
          <label for="room-name" class="label">Room Name</label>
          <input type="text" id="room-name" placeholder="My Room" class="input input-bordered w-full">
        </div>
        <div class="mb-4">
          <label for="room-password" class="label">Password (optional)</label>
          <input type="password" id="room-password" placeholder="Leave empty for no password" class="input input-bordered w-full">
        </div>
        <div class="form-control mb-4">
          <label class="cursor-pointer label">
            <span class="label-text">Public Room</span> 
            <input type="checkbox" id="room-public" class="checkbox" checked>
          </label>
        </div>
        <button id="create-room-btn" class="btn btn-primary" disabled>Create Room</button>
      </div>
      
      <div id="join-room-form" class="mb-6">
        <h3 class="text-xl font-semibold mb-2">Join Room</h3>
        <div class="mb-4">
          <label for="join-room-password" class="label">Password (if required)</label>
          <input type="password" id="join-room-password" placeholder="Enter room password" class="input input-bordered w-full">
        </div>
        <div class="mb-4">
          <label for="join-invite-token" class="label">Invite Token (if available)</label>
          <input type="text" id="join-invite-token" placeholder="Enter invite token" class="input input-bordered w-full">
        </div>
        <div class="flex gap-2">
          <button id="join-room-btn" class="btn btn-primary" disabled>Join Selected Room</button>
          <button id="leave-room-btn" class="btn btn-primary" disabled>Leave Current Room</button>
        </div>
      </div>
      
      <h3 class="text-xl font-semibold mb-2">Available Rooms</h3>
      <div id="room-list" class="max-h-72 overflow-y-auto">
        <div class="p-2 bg-base-200 rounded">Loading rooms...</div>
      </div>
    </div>
    
    <!-- Right Panel: Timers -->
    <div class="flex-1 card bg-white shadow p-6">
      <div id="current-room-info" class="mb-6">
        <h2 class="text-2xl font-semibold mb-2">
          Current Room: <span id="current-room-name" class="font-normal">None</span>
        </h2>
        <div id="room-details" class="bg-base-200 p-4 rounded hidden">
          <div><strong>Room ID:</strong> <span id="current-room-id"></span></div>
          <div><strong>Invite Token:</strong> <span id="current-room-token"></span></div>
        </div>
      </div>
      
      <div id="create-timer-form" class="mb-6">
        <h3 class="text-xl font-semibold mb-2">Create Timer</h3>
        <div class="mb-4">
          <label for="timer-name" class="label">Timer Name</label>
          <input type="text" id="timer-name" placeholder="My Timer" class="input input-bordered w-full">
        </div>
        <div class="mb-4">
          <label for="timer-duration" class="label">Duration (seconds)</label>
          <input type="number" id="timer-duration" value="60" min="1" class="input input-bordered w-full">
        </div>
        <button id="create-timer-btn" class="btn btn-primary" disabled>Create Timer</button>
      </div>
      
      <h3 class="text-xl font-semibold mb-2">Active Timers</h3>
      <div id="timer-list" class="max-h-72 overflow-y-auto">
        <div class="p-2 bg-base-200 rounded">Join a room to see timers</div>
      </div>
    </div>
  </div>
  
  <h3 class="text-xl font-semibold mt-6 mb-2">Connection Log</h3>
  <div id="log-container" class="bg-base-100 border border-base-300 rounded p-4 max-h-40 overflow-y-auto">
    <div class="font-mono">Waiting for connection...</div>
  </div>
  
  <script>
    document.addEventListener('DOMContentLoaded', function() {
      console.log('DOM fully loaded - starting application');
      initializeApp();
    });
    
    function initializeApp() {
      // Global variables
      let ws = null;
      let selectedRoomId = null;
      let currentRoomId = null;
      let availableRooms = [];
      let roomTimers = [];
      let timerIntervals = {};
      
      // DOM elements
      const connectBtn = document.getElementById('connect-btn');
      const disconnectBtn = document.getElementById('disconnect-btn');
      const serverUrlInput = document.getElementById('server-url');
      const connectionStatus = document.getElementById('connection-status');
      const logContainer = document.getElementById('log-container');
      
      const roomNameInput = document.getElementById('room-name');
      const roomPasswordInput = document.getElementById('room-password');
      const roomPublicCheckbox = document.getElementById('room-public');
      const createRoomBtn = document.getElementById('create-room-btn');
      
      const joinRoomPasswordInput = document.getElementById('join-room-password');
      const joinInviteTokenInput = document.getElementById('join-invite-token');
      const joinRoomBtn = document.getElementById('join-room-btn');
      const leaveRoomBtn = document.getElementById('leave-room-btn');
      
      const roomList = document.getElementById('room-list');
      const currentRoomName = document.getElementById('current-room-name');
      const currentRoomIdElement = document.getElementById('current-room-id');
      const currentRoomToken = document.getElementById('current-room-token');
      const roomDetails = document.getElementById('room-details');
      
      const timerNameInput = document.getElementById('timer-name');
      const timerDurationInput = document.getElementById('timer-duration');
      const createTimerBtn = document.getElementById('create-timer-btn');
      
      const timerList = document.getElementById('timer-list');
      
      // Helper functions
      function logMessage(message, data = null) {
        const now = new Date().toLocaleTimeString();
        const logEntry = document.createElement('div');
        logEntry.className = 'font-mono';
        logEntry.textContent = data ? `[${now}] ${message}: ${JSON.stringify(data, null, 2)}` : `[${now}] ${message}`;
        logContainer.appendChild(logEntry);
        logContainer.scrollTop = logContainer.scrollHeight;
      }
      
      function updateConnectionStatus(status) {
        connectionStatus.textContent = status;
        if (status.toLowerCase() === 'connected') {
          connectionStatus.className = 'alert alert-success mb-4 text-center';
        } else if (status.toLowerCase() === 'connecting') {
          connectionStatus.className = 'alert alert-warning mb-4 text-center';
        } else {
          connectionStatus.className = 'alert alert-error mb-4 text-center';
        }
      }
      
      function formatTime(seconds) {
        const minutes = Math.floor(seconds / 60);
        const remainingSeconds = seconds % 60;
        return `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
      }
      
      function getStatusBadge(status) {
        switch(status) {
          case 'created': return '<span class="badge badge-info">Created</span>';
          case 'running': return '<span class="badge badge-success">Running</span>';
          case 'paused': return '<span class="badge badge-warning">Paused</span>';
          case 'completed': return '<span class="badge badge-error">Completed</span>';
          default: return `<span class="badge">${status}</span>`;
        }
      }
      
      function displayRooms(rooms) {
        roomList.innerHTML = '';
        if (!rooms || rooms.length === 0) {
          const emptyItem = document.createElement('div');
          emptyItem.className = 'p-2 bg-base-200 rounded';
          emptyItem.textContent = 'No rooms available';
          roomList.appendChild(emptyItem);
          return;
        }
        rooms.forEach(room => {
          const roomItem = document.createElement('div');
          roomItem.className = 'p-2 bg-base-200 rounded mb-2 cursor-pointer hover:bg-base-300';
          if (selectedRoomId === room.id) {
            roomItem.classList.add('bg-success', 'border-l-4', 'border-success');
          }
          roomItem.setAttribute('data-room-id', room.id);
          
          const roomName = document.createElement('div');
          roomName.innerHTML = `<strong>${room.name || 'Unnamed Room'}</strong>`;
          
          const roomInfo = document.createElement('div');
          const isPublic = room.is_public === 1 || room.is_public === true;
          const clientCount = room.client_count || 0;
          roomInfo.textContent = `Public: ${isPublic ? 'Yes' : 'No'} - Clients: ${clientCount}`;
          
          roomItem.appendChild(roomName);
          roomItem.appendChild(roomInfo);
          
          roomItem.addEventListener('click', () => {
            document.querySelectorAll('[data-room-id].bg-success').forEach(el => {
              el.classList.remove('bg-success', 'border-l-4', 'border-success');
            });
            roomItem.classList.add('bg-success', 'border-l-4', 'border-success');
            selectedRoomId = room.id;
            joinRoomBtn.disabled = currentRoomId === selectedRoomId;
          });
          
          roomList.appendChild(roomItem);
        });
      }
      
      function renderTimerList() {
        timerList.innerHTML = '';
        if (!currentRoomId) {
          const emptyItem = document.createElement('div');
          emptyItem.className = 'p-2 bg-base-200 rounded';
          emptyItem.textContent = 'Join a room to see timers';
          timerList.appendChild(emptyItem);
          return;
        }
        if (roomTimers.length === 0) {
          const emptyItem = document.createElement('div');
          emptyItem.className = 'p-2 bg-base-200 rounded';
          emptyItem.textContent = 'No timers in this room';
          timerList.appendChild(emptyItem);
          return;
        }
        roomTimers.forEach(timer => {
          const timerItem = document.createElement('div');
          timerItem.className = 'p-4 bg-base-100 rounded mb-4';
          timerItem.setAttribute('data-timer-id', timer.id);
          
          // Header with timer name and status badge
          const headerDiv = document.createElement('div');
          headerDiv.innerHTML = `<strong>${timer.name}</strong> <span class="timer-status">${getStatusBadge(timer.status)}</span>`;
          
          // Progress bar
          const progressContainer = document.createElement('div');
          progressContainer.className = 'w-full bg-base-300 rounded h-4 my-2';
          const progressBar = document.createElement('div');
          progressBar.className = 'bg-primary h-4 rounded';
          const progressPercent = Math.max(0, Math.min(100, (timer.remaining / timer.duration) * 100));
          progressBar.style.width = `${progressPercent}%`;
          progressContainer.appendChild(progressBar);
          
          // Timer details
          const detailsDiv = document.createElement('div');
          detailsDiv.className = 'flex justify-between text-sm';
          detailsDiv.innerHTML = `<div>Total: ${formatTime(timer.duration)}</div><div class="timer-remaining">${formatTime(timer.remaining)}</div>`;
          
          // Controls: toggle (start/pause) and reset
          const controlsDiv = document.createElement('div');
          controlsDiv.className = 'flex gap-2 mt-2';
          
          const toggleBtn = document.createElement('button');
          if (timer.status === 'running') {
            toggleBtn.textContent = 'Pause';
            toggleBtn.className = 'btn btn-warning btn-sm';
          } else {
            toggleBtn.textContent = 'Start';
            toggleBtn.className = 'btn btn-success btn-sm';
          }
          toggleBtn.addEventListener('click', () => {
            if (toggleBtn.textContent === 'Pause') {
              const message = { type: 'pause_timer', timerId: timer.id };
              ws.send(JSON.stringify(message));
              logMessage('Pausing timer', message);
            } else {
              const message = { type: 'start_timer', timerId: timer.id };
              ws.send(JSON.stringify(message));
              logMessage('Starting timer', message);
            }
          });
          
          const resetBtn = document.createElement('button');
          resetBtn.textContent = 'Reset';
          resetBtn.className = 'btn btn-error btn-sm';
          resetBtn.addEventListener('click', () => {
            const message = { type: 'stop_timer', timerId: timer.id };
            ws.send(JSON.stringify(message));
            logMessage('Resetting timer', message);
          });
          
          controlsDiv.appendChild(toggleBtn);
          controlsDiv.appendChild(resetBtn);
          
          timerItem.appendChild(headerDiv);
          timerItem.appendChild(progressContainer);
          timerItem.appendChild(detailsDiv);
          timerItem.appendChild(controlsDiv);
          
          timerList.appendChild(timerItem);
          
          // Start an interval if timer is running and not already set
          if (timer.status === 'running' && !timerIntervals[timer.id]) {
            startTimerInterval(timer);
          }
        });
      }
      
      // Fixed: capture the paused remaining time so the timer resumes from where it left off.
      function startTimerInterval(timer) {
        if (timerIntervals[timer.id]) {
          clearInterval(timerIntervals[timer.id]);
        }
        if (timer.status !== 'running') return;
        
        let startRemaining = timer.remaining; // capture current remaining time at the moment of start
        const startTime = Date.now();
        timerIntervals[timer.id] = setInterval(() => {
          const elapsed = Math.floor((Date.now() - startTime) / 1000);
          const newRemaining = Math.max(0, startRemaining - elapsed);
          const updatedTimer = { ...timer, remaining: newRemaining };
          updateTimerDisplay(updatedTimer);
          if (newRemaining <= 0) {
            updatedTimer.status = 'completed';
            clearInterval(timerIntervals[timer.id]);
            delete timerIntervals[timer.id];
          }
        }, 1000);
      }
      
      function updateTimerDisplay(timer) {
        const timerElement = document.querySelector(`[data-timer-id="${timer.id}"]`);
        if (!timerElement) return;
        const progressBar = timerElement.querySelector('.bg-primary');
        const remainingTimeElement = timerElement.querySelector('.timer-remaining');
        const statusElement = timerElement.querySelector('.timer-status');
        
        const progressPercent = Math.max(0, Math.min(100, (timer.remaining / timer.duration) * 100));
        progressBar.style.width = `${progressPercent}%`;
        remainingTimeElement.textContent = formatTime(timer.remaining);
        statusElement.innerHTML = getStatusBadge(timer.status);
        
        const toggleBtn = timerElement.querySelector('button.btn-success, button.btn-warning');
        if (toggleBtn) {
          if (timer.status === 'running') {
            toggleBtn.textContent = 'Pause';
            toggleBtn.className = 'btn btn-warning btn-sm';
          } else {
            toggleBtn.textContent = 'Start';
            toggleBtn.className = 'btn btn-success btn-sm';
          }
        }
      }
      
      function updateUIForRoomJoined(room) {
        currentRoomId = room.id;
        currentRoomName.textContent = room.name;
        currentRoomIdElement.textContent = room.id;
        currentRoomToken.textContent = room.invite_token || 'None';
        roomDetails.classList.remove('hidden');
        leaveRoomBtn.disabled = false;
        createTimerBtn.disabled = false;
        joinRoomBtn.disabled = true;
        document.querySelectorAll('[data-room-id].bg-success').forEach(el => {
          if (el.getAttribute('data-room-id') !== room.id) {
            el.classList.remove('bg-success', 'border-l-4', 'border-success');
          } else {
            el.classList.add('bg-success', 'border-l-4', 'border-success');
          }
        });
      }
      
      function updateUIForRoomLeft() {
        currentRoomId = null;
        currentRoomName.textContent = 'None';
        roomDetails.classList.add('hidden');
        leaveRoomBtn.disabled = true;
        createTimerBtn.disabled = true;
        joinRoomBtn.disabled = !selectedRoomId;
        roomTimers = [];
        renderTimerList();
        Object.keys(timerIntervals).forEach(timerId => {
          clearInterval(timerIntervals[timerId]);
          delete timerIntervals[timerId];
        });
      }
      
      // WebSocket connection handling
      function connectToServer() {
        const serverUrl = serverUrlInput.value.trim();
        if (!serverUrl) {
          alert('Please enter a valid WebSocket server URL');
          return;
        }
        try {
          updateConnectionStatus('Connecting...');
          ws = new WebSocket(serverUrl);
          ws.onopen = () => {
            updateConnectionStatus('Connected');
            logMessage('Connected to server');
            connectBtn.disabled = true;
            disconnectBtn.disabled = false;
            createRoomBtn.disabled = false;
          };
          ws.onclose = () => {
            updateConnectionStatus('Disconnected');
            logMessage('Disconnected from server');
            connectBtn.disabled = false;
            disconnectBtn.disabled = true;
            createRoomBtn.disabled = true;
            joinRoomBtn.disabled = true;
            leaveRoomBtn.disabled = true;
            createTimerBtn.disabled = true;
            updateUIForRoomLeft();
            Object.keys(timerIntervals).forEach(timerId => {
              clearInterval(timerIntervals[timerId]);
              delete timerIntervals[timerId];
            });
          };
          ws.onerror = (error) => {
            updateConnectionStatus('Error');
            logMessage('WebSocket error', 'Connection failed.');
            alert('Failed to connect to the WebSocket server.');
          };
          ws.onmessage = (event) => {
            try {
              const message = JSON.parse(event.data);
              logMessage('Received message', message);
              switch(message.type) {
                case 'available_rooms':
                  availableRooms = message.rooms || [];
                  displayRooms(availableRooms);
                  break;
                case 'room_created':
                  logMessage('Room created successfully', message.room);
                  updateUIForRoomJoined(message.room);
                  break;
                case 'room_joined':
                  logMessage('Joined room', message.room);
                  updateUIForRoomJoined(message.room);
                  roomTimers = message.timers || [];
                  renderTimerList();
                  break;
                case 'room_left':
                  logMessage('Left room');
                  updateUIForRoomLeft();
                  break;
                case 'timer_list':
                  roomTimers = message.timers || [];
                  renderTimerList();
                  break;
                case 'timer_created':
                  logMessage('Timer created', message.timer);
                  roomTimers.push(message.timer);
                  renderTimerList();
                  break;
                case 'timer_started':
                  logMessage('Timer started', message.timer);
                  roomTimers = roomTimers.map(t => t.id === message.timer.id ? message.timer : t);
                  renderTimerList();
                  break;
                case 'timer_paused':
                  logMessage('Timer paused', message.timer);
                  if (timerIntervals[message.timer.id]) {
                    clearInterval(timerIntervals[message.timer.id]);
                    delete timerIntervals[message.timer.id];
                  }
                  roomTimers = roomTimers.map(t => t.id === message.timer.id ? message.timer : t);
                  renderTimerList();
                  break;
                case 'timer_completed':
                  logMessage('Timer completed', message.timer);
                  if (timerIntervals[message.timer.id]) {
                    clearInterval(timerIntervals[message.timer.id]);
                    delete timerIntervals[message.timer.id];
                  }
                  roomTimers = roomTimers.map(t => t.id === message.timer.id ? message.timer : t);
                  renderTimerList();
                  break;
                case 'ping':
                  logMessage('Received ping from server');
                  if (ws && ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({ type: 'pong' }));
                    logMessage('Sent pong response');
                  }
                  break;
                case 'pong':
                  logMessage('Received pong from server');
                  break;
                case 'error':
                  logMessage('Error from server', message);
                  alert(`Server error: ${message.message}`);
                  break;
                default:
                  logMessage('Unknown message type', message);
              }
            } catch (error) {
              logMessage('Error parsing message', error.message);
            }
          };
          const pingInterval = setInterval(() => {
            if (ws && ws.readyState === WebSocket.OPEN) {
              ws.send(JSON.stringify({ type: 'ping' }));
              logMessage('Sent ping to server');
            } else {
              clearInterval(pingInterval);
            }
          }, 20000);
        } catch (error) {
          updateConnectionStatus('Error');
          logMessage('Connection error', error.message);
        }
      }
      
      function disconnectFromServer() {
        if (ws) {
          ws.close();
          ws = null;
        }
      }
      
      // Event listeners
      connectBtn.addEventListener('click', connectToServer);
      disconnectBtn.addEventListener('click', disconnectFromServer);
      
      createRoomBtn.addEventListener('click', () => {
        if (!ws || ws.readyState !== WebSocket.OPEN) {
          alert('Not connected to server');
          return;
        }
        const roomName = roomNameInput.value.trim();
        if (!roomName) {
          alert('Please enter a room name');
          return;
        }
        const message = {
          type: 'create_room',
          name: roomName,
          isPublic: roomPublicCheckbox.checked
        };
        const password = roomPasswordInput.value.trim();
        if (password) {
          message.password = password;
        }
        ws.send(JSON.stringify(message));
        logMessage('Creating room', message);
      });
      
      joinRoomBtn.addEventListener('click', () => {
        if (!ws || ws.readyState !== WebSocket.OPEN) {
          alert('Not connected to server');
          return;
        }
        if (!selectedRoomId) {
          alert('Please select a room to join');
          return;
        }
        const message = {
          type: 'join_room',
          roomId: selectedRoomId
        };
        const password = joinRoomPasswordInput.value.trim();
        if (password) {
          message.password = password;
        }
        const inviteToken = joinInviteTokenInput.value.trim();
        if (inviteToken) {
          message.inviteToken = inviteToken;
        }
        ws.send(JSON.stringify(message));
        logMessage('Joining room', message);
      });
      
      leaveRoomBtn.addEventListener('click', () => {
        if (!ws || ws.readyState !== WebSocket.OPEN) {
          alert('Not connected to server');
          return;
        }
        if (!currentRoomId) {
          alert('Not in a room');
          return;
        }
        ws.send(JSON.stringify({ type: 'leave_room' }));
        logMessage('Leaving room');
      });
      
      createTimerBtn.addEventListener('click', () => {
        if (!ws || ws.readyState !== WebSocket.OPEN) {
          alert('Not connected to server');
          return;
        }
        if (!currentRoomId) {
          alert('Not in a room');
          return;
        }
        const timerName = timerNameInput.value.trim();
        if (!timerName) {
          alert('Please enter a timer name');
          return;
        }
        const timerDuration = parseInt(timerDurationInput.value);
        if (isNaN(timerDuration) || timerDuration <= 0) {
          alert('Please enter a valid duration');
          return;
        }
        const message = {
          type: 'create_timer',
          name: timerName,
          duration: timerDuration
        };
        ws.send(JSON.stringify(message));
        logMessage('Creating timer', message);
      });
      
      if (serverUrlInput.value) {
        connectBtn.click();
      }
    }
  </script>
</body>
</html>
